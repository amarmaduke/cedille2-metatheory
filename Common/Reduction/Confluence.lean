import Common.Term
import Common.Term.Substitution
import Common.Reduction.Definition
import Common.Reduction.Basic

-- namespace ParRed

--   @[simp]
--   theorem refl1 t : t =β> t := by
--   induction t; all_goals constructor <;> simp [*]

--   theorem refl t : t =β>* t := by constructor

--   theorem trans_flip : x =β>* y -> y =β> z -> x =β>* z := by
--   intro h1 h2
--   induction h1
--   case _ => apply ParRedStar.step h2; apply refl
--   case _ h3 _h4 ih =>  apply ParRedStar.step h3 (ih h2)

--   theorem trans : x =β>* y -> y =β>* z -> x =β>* z := by
--   intro h1 h2
--   induction h2; simp [*]
--   case _ r1 _r2 ih =>
--     apply ih; apply trans_flip h1 r1

--   theorem from_red : s -β> t -> s =β> t := by
--   intro h
--   induction h
--   all_goals (try constructor <;> simp [*])
--   case beta => constructor; repeat apply refl1
--   case proj1 => constructor; repeat apply refl1
--   case proj2 => constructor; repeat apply refl1
--   repeat sorry

--   theorem from_redstar : s -β>* t -> s =β>* t := by
--   intro h
--   induction h
--   case _ => constructor
--   case _ h1 _h2 ih => constructor; apply (from_red h1); apply ih

--   theorem to_red : s =β> t -> s -β>* t := by
--   intro h
--   induction h
--   case bound => apply Term.Red.refl
--   case none => apply Term.Red.refl
--   case const => apply Term.Red.refl
--   case beta A _A' b b' t t' m _ _ _ _ih1 ih2 ih3 =>
--     have r1 := Red.congr2 (λ b t => .app m (.lam m A b) t)
--       (by {
--         intro t1 t2 t1' h; simp
--         apply Red.app_congr1; apply Red.lam_congr2; apply h
--       })
--       (by {
--         intro t1 t2 t2' h; simp
--         apply Red.app_congr2; apply h
--       })
--       ih2 ih3
--     simp at r1
--     apply Red.trans_flip; apply r1; constructor
--   case proj1 B _B' t t' s _s' _ _ _ _ih1 ih2 _ih3 =>
--     have r1 := Red.congr1 (λ t => .fst (.pair B t s))
--       (by {
--         intro t t' h; simp
--         apply Red.fst_congr; apply Red.pair_congr2; apply h
--       })
--       ih2
--     simp at r1
--     apply Red.trans_flip; apply r1; constructor
--   case proj2 B _B' t _t' s s' _ _ _ _ih1 _ih2 ih3 =>
--     have r1 := Red.congr1 (λ s => .snd (.pair B t s))
--       (by {
--         intro t t' h; simp
--         apply Red.snd_congr; apply Red.pair_congr3; apply h
--       })
--       ih3
--     simp at r1
--     apply Red.trans_flip; apply r1; constructor
--   -- case substelim B B' t t' _ _ ih1 ih2 =>
--   --   have r1 := Red.congr2 (λ B t => .subst B (.refl t))
--   --     (by {
--   --       intro t1 t2 t1' h; simp
--   --       apply Red.subst_congr1; apply h
--   --     })
--   --     (by {
--   --       intro t1 t2 t2' h; simp
--   --       apply Red.subst_congr2; apply Red.refl_congr; apply h
--   --     })
--   --     ih1 ih2
--   --   simp at r1
--   --   apply Red.trans_flip; apply r1; constructor
--   -- case conv_lam B B' A2 A2' t t' m A1 n _ _ ih1 ih2 ih3 ih4 =>
--   --   apply Red.trans; apply Red.congr1 (λ A2 => (all m A1 B).conv (lam m A2 t) n)
--   --   intro t1 t1' h; apply Red.conv_congr2; apply Red.lam_congr1; apply h
--   --   apply ih3;
--   --   apply RedStar.step; apply Red.conv_lam
--   --   apply Red.congr2 (λ B t => lam m A2' (conv B t n))
--   --   intro t1 t2 t1' h; apply Red.lam_congr2; apply Red.conv_congr1; apply h
--   --   intro t1 t2 t2' h; apply Red.lam_congr2; apply Red.conv_congr2; apply h
--   --   apply ih2; apply ih4
--   -- case conv_pair T T' t t' s s' n _ _ _ ih1 ih2 ih3 =>
--   --   apply RedStar.step; constructor
--   --   apply Red.congr3 (λ T t s => pair T t s)
--   --   intro t1 t2 t3 t1' h; apply Red.pair_congr1; apply h
--   --   intro t1 t2 t3 t2' h; apply Red.pair_congr2; apply h
--   --   intro t1 t2 t3 t3' h; apply Red.pair_congr3; apply h
--   --   apply ih1; apply ih2; apply ih3
--   -- case conv_refl A A' t t' n _ _ ih1 ih2 =>
--   --   apply RedStar.step; constructor
--   --   apply Red.congr2 (λ A t => Term.refl (conv A t n))
--   --   intro t1 t2 t1' h; apply Red.refl_congr; apply Red.conv_congr1; apply h
--   --   intro t1 t2 t2' h; apply Red.refl_congr; apply Red.conv_congr2; apply h
--   --   apply ih1; apply ih2
--   case conv_all A A' B B' K m n _ _ ih1 ih2 =>
--     apply RedStar.step; constructor
--     apply Red.congr2 (λ A B => all m A B)
--     intro t1 t2 t1' h; apply Red.all_congr1; apply h
--     intro t1 t2 t2' h; apply Red.all_congr2; apply h
--     apply ih1; apply ih2
--   case conv_prod A A' B B' n _ _ ih1 ih2 =>
--     apply RedStar.step; constructor
--     apply Red.congr2 (λ A B => prod A B)
--     intro t1 t2 t1' h; apply Red.prod_congr1; apply h
--     intro t1 t2 t2' h; apply Red.prod_congr2; apply h
--     apply ih1; apply ih2
--   case conv_eq A A' a a' b b' n _ _ _ ih1 ih2 ih3 =>
--     apply RedStar.step; constructor
--     apply Red.congr3 (λ A a b => eq A a b)
--     intro t1 t2 t3 t1' h; apply Red.eq_congr1; apply h
--     intro t1 t2 t3 t2' h; apply Red.eq_congr2; apply h
--     intro t1 t2 t3 t3' h; apply Red.eq_congr3; apply h
--     apply ih1; apply ih2; apply ih3
--   case lam_congr ih1 ih2 => apply Red.congr2 (.lam _) .lam_congr1 .lam_congr2 ih1 ih2
--   case app_congr ih1 ih2 => apply Red.congr2 (.app _) .app_congr1 .app_congr2 ih1 ih2
--   case all_congr ih1 ih2 => apply Red.congr2 (.all _) .all_congr1 .all_congr2 ih1 ih2
--   case pair_congr ih1 ih2 ih3 => apply Red.congr3 .pair .pair_congr1 .pair_congr2 .pair_congr3 ih1 ih2 ih3
--   case fst_congr ih => apply Red.congr1 .fst .fst_congr ih
--   case snd_congr ih => apply Red.congr1 .snd .snd_congr ih
--   case prod_congr ih1 ih2 => apply Red.congr2 .prod .prod_congr1 .prod_congr2 ih1 ih2
--   case refl_congr ih => apply Red.congr1 .refl .refl_congr ih
--   case subst_congr ih1 ih2 => apply Red.congr2 .subst .subst_congr1 .subst_congr2 ih1 ih2
--   case phi_congr ih1 ih2 ih3 => apply Red.congr3 .phi .phi_congr1 .phi_congr2 .phi_congr3 ih1 ih2 ih3
--   case eq_congr ih1 ih2 ih3 => apply Red.congr3 .eq .eq_congr1 .eq_congr2 .eq_congr3 ih1 ih2 ih3
--   case conv_congr ih1 ih2 => apply Red.congr2 (λ t1 t2 => .conv t1 t2 _) .conv_congr1 .conv_congr2 ih1 ih2
--   repeat sorry

--   theorem to_redstar : s =β>* t -> s -β>* t := by
--   intro h
--   induction h
--   case _ => apply Red.refl
--   case _ h _ ih => apply Red.trans (to_red h) ih

--   theorem subst_same σ : s =β> t -> [σ]s =β> [σ]t := by
--   intro h
--   induction h generalizing σ
--   case bound _ n => simp
--   case none => simp
--   case const => simp
--   case beta A A' b b' t t' m _ _ _ ih1 ih2 ih3 =>
--     have h3 := @ParRed.beta ([σ]A) ([σ]A') ([^σ]b) ([^σ]b') ([σ]t) ([σ]t') m
--     simp at *; apply h3
--     apply ih1 σ
--     replace ih2 := ih2 (^σ)
--     simp at ih2; apply ih2
--     apply ih3 σ
--   case proj1 B B' t t' s s' _ _ _ ih1 ih2 ih3 =>
--     have h3 := @ParRed.proj1 ([σ]B) ([σ]B') ([σ]t) ([σ]t') ([σ]s) ([σ]s')
--     simp at *; apply h3
--     apply ih1 σ; apply ih2 σ; apply ih3 σ
--   case proj2 B B' t t' s s' _ _ _ ih1 ih2 ih3 =>
--     have h3 := @ParRed.proj2 ([σ]B) ([σ]B') ([σ]t) ([σ]t') ([σ]s) ([σ]s')
--     simp at *; apply h3
--     apply ih1 σ; apply ih2 σ; apply ih3 σ
--   case substelim B B' t t' _ _ ih1 ih2 =>
--     have h3 := @ParRed.substelim ([σ]B) ([σ]B') ([σ]t) ([σ]t')
--     simp at *; apply h3
--     apply ih1 σ; apply ih2 σ
--   case lam_congr ih1 ih2 =>
--     simp; constructor; apply ih1 σ
--     replace ih2 := ih2 (^σ)
--     simp at ih2; exact ih2
--   case all_congr ih1 ih2 =>
--     simp; constructor; apply ih1 σ
--     replace ih2 := ih2 (^σ)
--     simp at ih2; exact ih2
--   case prod_congr ih1 ih2 =>
--     simp; constructor; apply ih1 σ
--     replace ih2 := ih2 (^σ)
--     simp at ih2; exact ih2
--   case conv_lam ih1 ih2 ih3 =>
--     simp; constructor
--     replace ih1 := ih1 (^σ)
--     simp at ih1; exact ih1
--     apply ih2 σ
--     replace ih3 := ih3 (^σ)
--     simp at ih3; exact ih3
--   case conv_pair ih1 ih2 ih3 =>
--     simp; constructor; apply ih1 _; apply ih2 _; apply ih3 _
--   case conv_all ih1 ih2 =>
--     simp; constructor; apply ih1 σ
--     replace ih2 := ih2 (^σ)
--     simp at ih2; exact ih2
--   case conv_prod ih1 ih2 =>
--     simp; constructor; apply ih1 σ
--     replace ih2 := ih2 (^σ)
--     simp at ih2; exact ih2
--   all_goals try (
--     case _ ih1 => simp at *; constructor; apply ih1 σ
--   )
--   all_goals try (
--     case _ ih1 ih2 => simp at *; constructor; apply ih1 σ; apply ih2 σ
--   )
--   all_goals try (
--     case _ ih1 ih2 ih3 => simp at *; constructor; apply ih1 σ; apply ih2 σ; apply ih3 σ
--   )

--   theorem subst_lift_replace σ τ :
--     (∀ n t, σ n = .replace t -> ∃ t', τ n = .replace t' ∧ t =β> t') ->
--     ∀ n t, ^σ n = .replace t -> ∃ t', ^τ n = .replace t' ∧ t =β> t'
--   := by
--   intro h1 n t h2
--   cases n <;> simp at *
--   case _ n =>
--     unfold Subst.compose at *; simp at *
--     generalize ydef : σ n = y at *
--     cases y <;> simp at *
--     case _ q =>
--       replace h1 := h1 n q ydef
--       cases h1
--       case _ w h1 =>
--         rw [h1.1]; simp
--         subst h2; apply subst_same; apply h1.2

--   theorem subst (σ τ : Subst Term) :
--     (∀ n t, σ n = .replace t -> ∃ t', τ n = .replace t' ∧ t =β> t') ->
--     (∀ n k, σ n = .rename k -> τ n = .rename k) ->
--     s =β> t -> [σ]s =β> [τ]t
--   := by
--   intro h1 h2 r
--   induction r generalizing σ τ
--   case bound _ n =>
--     simp; generalize ydef : σ n = y at *
--     cases y <;> simp
--     case _ i => rw [h2 n i]; simp; rw [ydef]
--     case _ t =>
--       replace h1 := h1 n t ydef
--       cases h1
--       case _ t' h1 =>
--         rw [h1.1]; simp; apply h1.2
--   case none => simp
--   case const => simp
--   case beta A A' b b' t t' m _ _ _ ih1 ih2 ih3 =>
--     have h3 := @ParRed.beta ([σ]A) ([τ]A') ([^σ]b) ([^τ]b') ([σ]t) ([τ]t') m
--     simp at *; apply h3
--     apply ih1 _ _ h1 h2
--     replace ih2 := ih2 (^σ) (^τ) (subst_lift_replace _ _ h1) (Red.subst_lift_rename _ _ h2)
--     simp at ih2; apply ih2
--     apply ih3 _ _ h1 h2
--   case proj1 B B' t t' s s' _ _ _ ih1 ih2 ih3 =>
--     have h3 := @ParRed.proj1 ([σ]B) ([τ]B') ([σ]t) ([τ]t') ([σ]s) ([τ]s')
--     simp at *; apply h3
--     apply ih1 _ _ h1 h2; apply ih2 _ _ h1 h2; apply ih3 _ _ h1 h2
--   case proj2 B B' t t' s s' _ _ _ ih1 ih2 ih3 =>
--     have h3 := @ParRed.proj2 ([σ]B) ([τ]B') ([σ]t) ([τ]t') ([σ]s) ([τ]s')
--     simp at *; apply h3
--     apply ih1 _ _ h1 h2; apply ih2 _ _ h1 h2; apply ih3 _ _ h1 h2
--   case substelim B B' t t' _ _ ih1 ih2 =>
--     have h3 := @ParRed.substelim ([σ]B) ([τ]B') ([σ]t) ([τ]t')
--     simp at *; apply h3
--     apply ih1 _ _ h1 h2; apply ih2 _ _ h1 h2
--   case conv_lam B B' A2 A2' t t' m A1 n _ _ _ ih1 ih2 ih3 =>
--     have h3 := @ParRed.conv_lam ([^σ]B) ([^τ]B') ([σ]A2) ([τ]A2') ([^σ]t) ([^τ]t') m ([σ]A1) n
--     simp at *; apply h3
--     replace ih1 := ih1 (^σ) (^τ) (subst_lift_replace _ _ h1) (Red.subst_lift_rename _ _ h2)
--     simp at ih1; apply ih1
--     apply ih2 _ _ h1 h2
--     replace ih3 := ih3 (^σ) (^τ) (subst_lift_replace _ _ h1) (Red.subst_lift_rename _ _ h2)
--     simp at ih3; apply ih3
--   case conv_pair T T' t t' s s' n _ _ _ ih1 ih2 ih3 =>
--     have h3 := @ParRed.conv_pair ([σ]T) ([τ]T') ([σ]t) ([τ]t') ([σ]s) ([τ]s') n
--     simp at *; apply h3
--     apply ih1 _ _ h1 h2; apply ih2 _ _ h1 h2; apply ih3 _ _ h1 h2
--   case conv_all A A' B B' K m n _ _ ih1 ih2 =>
--     have h3 := @ParRed.conv_all ([σ]A) ([τ]A') ([^σ]B) ([^τ]B') K m
--     simp at *; apply h3
--     apply ih1 _ _ h1 h2
--     replace ih2 := ih2 (^σ) (^τ) (subst_lift_replace _ _ h1) (Red.subst_lift_rename _ _ h2)
--     simp at ih2; apply ih2
--   case conv_prod A A' B B' n _ _ ih1 ih2 =>
--     have h3 := @ParRed.conv_prod ([σ]A) ([τ]A') ([^σ]B) ([^τ]B')
--     simp at *; apply h3
--     apply ih1 _ _ h1 h2
--     replace ih2 := ih2 (^σ) (^τ) (subst_lift_replace _ _ h1) (Red.subst_lift_rename _ _ h2)
--     simp at ih2; apply ih2
--   case lam_congr ih1 ih2 =>
--     simp; constructor; apply ih1 _ _ h1 h2
--     replace ih2 := ih2 (^σ) (^τ) (subst_lift_replace _ _ h1) (Red.subst_lift_rename _ _ h2)
--     simp at ih2; exact ih2
--   case all_congr ih1 ih2 =>
--     simp; constructor; apply ih1 _ _ h1 h2
--     replace ih2 := ih2 (^σ) (^τ) (subst_lift_replace _ _ h1) (Red.subst_lift_rename _ _ h2)
--     simp at ih2; exact ih2
--   case prod_congr ih1 ih2 =>
--     simp; constructor; apply ih1 _ _ h1 h2
--     replace ih2 := ih2 (^σ) (^τ) (subst_lift_replace _ _ h1) (Red.subst_lift_rename _ _ h2)
--     simp at ih2; exact ih2
--   all_goals try (
--     case _ ih1 =>
--     simp; constructor; apply ih1 _ _ h1 h2
--   )
--   all_goals try (
--     case _ ih1 ih2 =>
--     simp; constructor; apply ih1 _ _ h1 h2; apply ih2 _ _ h1 h2
--   )
--   all_goals try (
--     case _ ih1 ih2 ih3 =>
--     simp; constructor; apply ih1 _ _ h1 h2; apply ih2 _ _ h1 h2; apply ih3 _ _ h1 h2
--   )

--   theorem subst_beta : b =β> b' -> t =β> t' -> b β[t] =β> b' β[t'] := by
--   intro h1 h2
--   apply subst <;> simp [*]
--   case _ =>
--     intro n x h
--     cases n <;> simp at *
--     case _ => subst h; apply h2
--   case _ =>
--     intro n x h
--     cases n <;> simp at *
--     case _ => exact h

--   theorem complete : s =β> t -> t =β> pcompl s := by
--   intro h
--   induction h
--   case beta m _ _ _ _ _ _ =>
--     cases m <;> simp
--     all_goals (
--       apply subst
--       case _ =>
--         intro n t h; simp at *
--         cases n <;> simp at *
--         subst h; simp [*]
--       case _ =>
--         intro n k h; simp at *
--         cases n <;> simp at * <;> simp [*]
--       case _ => simp [*]
--     )
--   case proj1 => simp [*]
--   case proj2 => simp [*]
--   case substelim =>
--     simp; constructor; constructor;
--     all_goals simp [*]
--   case conv_lam ih1 ih2 ih3 ih4 =>
--     simp; constructor; apply ih3; constructor; apply ih2; apply ih4
--   case conv_pair ih1 ih2 ih3 =>
--     simp; constructor; apply ih1; apply ih2; apply ih3
--   case conv_refl ih1 ih2 =>
--     simp; constructor; constructor; apply ih1; apply ih2
--   case app_congr f f' a a' m h1 _h2 ih1 ih2 =>
--     cases m
--     case _ =>
--       cases f
--       all_goals (try constructor; apply ih1; apply ih2)
--       case _ m' _ _ =>
--       cases m' <;> simp at*
--       case _ =>
--         cases f' <;> cases h1
--         case _ r1 r2 =>
--           cases ih1
--           case _ h1 h2 =>
--             apply ParRed.beta; apply h1; apply h2; apply ih2
--       case _ => apply ParRed.app_congr <;> simp [*]
--       case _ => apply ParRed.app_congr <;> simp [*]
--     case _ =>
--       cases f
--       all_goals (try constructor; apply ih1; apply ih2)
--       case _ m' _ _ =>
--       cases m' <;> simp at *
--       case _ => apply ParRed.app_congr <;> simp [*]
--       case _ =>
--         cases f' <;> cases h1
--         case _ r1 r2 =>
--           cases ih1
--           case _ h1 h2 =>
--             apply ParRed.beta; apply h1; apply h2; apply ih2
--       case _ => apply ParRed.app_congr <;> simp [*]
--     case _ =>
--       cases f
--       all_goals (try constructor; apply ih1; apply ih2)
--       case _ m' _ _ =>
--       cases m' <;> simp at *
--       case _ => apply ParRed.app_congr <;> simp [*]
--       case _ => apply ParRed.app_congr <;> simp [*]
--       case _ =>
--         cases f' <;> cases h1
--         case _ r1 r2 =>
--           cases ih1
--           case _ h1 h2 =>
--             apply ParRed.beta; apply h1; apply h2; apply ih2
--   case fst_congr t t' h ih =>
--     cases t <;> simp at *
--     all_goals (try constructor; apply ih)
--     case pair B t s =>
--       cases t' <;> try cases h
--       case _ h1 h2 h3 =>
--         cases ih
--         case _ r1 r2 r3 =>
--           apply ParRed.proj1
--           apply r1; apply r2; apply r3
--   case snd_congr t t' h ih =>
--     cases t <;> simp at *
--     all_goals (try constructor; apply ih)
--     case pair B t s =>
--       cases t' <;> try cases h
--       case _ h1 h2 h3 =>
--         cases ih
--         case _ r1 r2 r3 =>
--           apply ParRed.proj2
--           apply r1; apply r2; apply r3
--   case subst_congr B B' e e' _h1 h2 ih1 ih2 =>
--     cases e <;> simp at *
--     all_goals (try constructor; apply ih1; apply ih2)
--     case _ e =>
--       cases e' <;> try cases h2
--       case _ h =>
--         cases ih2
--         case _ r =>
--           apply ParRed.substelim; apply ih1; apply r
--   case conv_congr A A' t t' n h1 h2 ih1 ih2 =>
--     cases t <;> simp at *
--     all_goals (try constructor; apply ih1; apply ih2)
--     case lam m1 u1 u2 =>
--       cases t' <;> try cases h2
--       case _ t1 t2 r1 h =>
--         cases ih2
--         case _ r2 r3 =>
--           cases A <;> simp [*]
--           all_goals (try constructor; apply ih1; constructor <;> simp [*])
--           case _ m2 v1 v2 =>
--             cases h1; cases ih1
--             case _  A' B' r4 r5 r6 r7 =>
--               sorry
--     case all => sorry
--     case prod => sorry
--     case pair => sorry
--     case refl => sorry
--     case eq => sorry

--   all_goals (try simp; constructor <;> simp [*])
--   all_goals (try simp)

--   theorem strip : s =β> t1 -> s =β>* t2 -> ∃ t, t1 =β>* t ∧ t2 =β> t := by
--   intro h1 h2
--   induction h2 generalizing t1
--   case _ t' => exists t1; apply And.intro; apply refl; apply h1
--   case _ x y z r1 _r2 ih =>
--     have r3 := complete r1
--     replace ih := ih r3
--     cases ih
--     case _ w ih =>
--       replace _r3 := ParRedStar.step r3 ih.1
--       replace h1 := complete h1
--       replace r3 := ParRedStar.step h1 ih.1
--       exists w; apply And.intro; apply r3; apply ih.2

--   theorem confluence : s =β>* t1 -> s =β>* t2 -> t1 ≡β≡ t2 := by
--   intro h1 h2
--   induction h1 generalizing t2
--   case _ z =>
--     exists t2; apply And.intro
--     apply h2; apply refl
--   case _ s y t1 r1 _r2 ih =>
--     have h3 := strip r1 h2
--     cases h3
--     case _ w h3 =>
--       replace ih := ih h3.1
--       cases ih
--       case _ q ih =>
--         exists q; apply And.intro
--         apply ih.1; apply ParRedStar.step
--         apply h3.2; apply ih.2

-- end ParRed

-- namespace ParRedConv

--   theorem refl : A ≡β≡ A := by
--   induction A
--   all_goals (
--     apply Exists.intro; apply And.intro
--     apply ParRedStar.refl; apply ParRedStar.refl
--   )

--   theorem sym : A ≡β≡ B -> B ≡β≡ A := by
--   intro h
--   cases h
--   case _ C ih => exists C; simp [*]

--   theorem trans : A ≡β≡ B -> B ≡β≡ C -> A ≡β≡ C := by
--   intro h1 h2
--   cases h1
--   case _ C1 ih1 =>
--     cases h2
--     case _ C2 ih2 =>
--       have conf := ParRed.confluence ih1.2 ih2.1
--       cases conf
--       case _ Z ih =>
--         exists Z; apply And.intro
--         apply ParRed.trans ih1.1 ih.1
--         apply ParRed.trans ih2.2 ih.2

-- end ParRedConv

namespace Red

  theorem confluence : s -β>* t1 -> s -β>* t2 -> t1 =β= t2 := by sorry
  -- intro h1 h2
  -- replace h1 := ParRed.from_redstar h1
  -- replace h2 := ParRed.from_redstar h2
  -- have conf := ParRed.confluence h1 h2
  -- cases conf
  -- case _ t conf =>
  --   exists t; apply And.intro
  --   apply ParRed.to_redstar conf.1
  --   apply ParRed.to_redstar conf.2

end Red

namespace RedConv

  theorem trans : A =β= B -> B =β= C -> A =β= C := by
  intro h1 h2
  unfold RedConv at *
  cases h1
  case _ C1 ih1 =>
    cases h2
    case _ C2 ih2 =>
      have conf := Red.confluence ih1.2 ih2.1
      cases conf
      case _ Z ih =>
        exists Z; apply And.intro
        apply Red.trans ih1.1 ih.1
        apply Red.trans ih2.2 ih.2

end RedConv
