
-- import Cedille2Lean.Util
-- import Cedille2Lean.SystemFOmega.Def

-- namespace SystemFOmega

--   namespace Conv
--     lemma sym : A =β= B -> B =β= A := sorry

--   end Conv

--   lemma infer_implies_coninfer : Γ ⊢ t : A -> Γ ⊢ t >: A := by
--     intro j
--     have lem1 : A -β>* A := RedStar.refl
--     apply (ConInfer.infer j lem1)

--   lemma coninfer_implies_check : Γ ⊢ t >: A -> Γ ⊢ t =: A := by
--     intro j
--     cases j
--     case infer A' j step => {
--       have lem1 : A =β= A' := Conv.conv (RedStar.refl) step (by rfl)
--       apply (Check.check j (Conv.sym lem1))
--     }

--   lemma infer_implies_check : Γ ⊢ t : A -> Γ ⊢ t =: A :=
--     λ j => coninfer_implies_check (infer_implies_coninfer j)

--   lemma infer_implies_wf : Γ ⊢ t : A -> ⊢ Γ :=
--     λ j => @Infer.rec
--       (λ Γ A t _ => ⊢ Γ)
--       (λ Γ A t _ => ⊢ Γ)
--       (λ Γ A t _ => True)
--       (λ Γ _ => True)
--       (by simp)
--       (by {
--         simp; intro Γ Γ1 x Γ2 A wf _e
--         exact wf
--       })
--       (by {
--         simp; intro Γ A B S _ih1 _ih2 wf _ih3
--         exact wf
--       })
--       (by {
--         simp; intro Γ A B S ih1 _ih2 _ih3 wf _ih4
--         exact wf
--       })
--       (by {
--         simp; intro Γ A K N B S _ih1 _ih2 wf _ih3
--         exact wf
--       })
--       (by simp)
--       (by simp)
--       (by simp)
--       (by simp)
--       (by simp)
--       (Γ)
--       (t)
--       (A)
--       (j)

--   -- lemma substitution' {N : Term 0} : Δ ⊢ t : A -> Δ = Γ ++ [x : N] -> Γ ⊢ [x := N]t : [x := N]A :=
--   --   λ j e => @Infer.rec
--   --     (λ Γ A t j => Γ ⊢ [x := N]t : [x := N]A)
--   --     (λ Γ A t j => True)
--   --     (λ Γ A t j => True)
--   --     (λ Γ j => True)
--   --     (sorry)
--   --     (sorry)
--   --     (sorry)
--   --     (sorry)
--   --     (sorry)
--   --     (sorry)
--   --     (sorry)
--   --     (sorry)
--   --     (sorry)
--   --     (sorry)
--   --     (Γ ++ [x : N])
--   --     (t)
--   --     (A)
--   --     (j)

--   lemma wf_left : ⊢ (Γ ++ Δ) -> ⊢ Γ :=
--     λ wf => @Wf.rec
--       (λ Γ t A j => True)
--       (λ Γ t A j => True)
--       (λ Γ t A j => True)
--       (λ Γ j => (Δ1 Δ2 : Map! (Term 0)) -> Γ = Δ1 ++ Δ2 -> ⊢ Δ1)
--       (by simp)
--       (by simp)
--       (by simp)
--       (by simp)
--       (by simp)
--       (by simp)
--       (by simp)
--       (by simp)
--       (by { simp; constructor })
--       (by {
--         simp
--         intros x Γ A K nin wf ih1 ih2 Δ1 Δ2 e
--         have lem1 := Map.append_cases Δ2
--         cases lem1
--         case inl h => {
--           subst h
--           have lem2 : Δ1 = Γ ++ [x:A] := sorry
--           subst lem2
--           apply (Wf.append nin wf ih1)
--         }
--         case inr h => {
--           casesm* ∃ _ , _
--           case _ x' A' Δ3 h =>
--           subst h; rewrite [<- List.append_assoc Δ1 Δ3 [x':A']] at e
--           have lem1 := append_eq e
--           casesm* _ ∧ _
--           case _ l r =>
--           apply (ih2 Δ1 Δ3 l)
--         }
--       })
--       (Γ ++ Δ)
--       (wf)
--       (Γ)
--       (Δ)
--       (by rfl)

--   lemma wf_right : ⊢ (Γ ++ Δ) -> ⊢ Δ := by sorry

--   @[simp] lemma subst_typeu {N : Term n} : [x := N](@typeu n) = typeu := by congr
--   @[simp] lemma subst_kindu {N : Term n} : [x := N](@kindu n) = kindu := by congr
--   @[simp] lemma subst_const {N : Term n} : [x := N](@const n K) = const K := by congr
--   @[simp] lemma subst_pi {N : Term n} {B : Term (n + 1)}
--     : [x := N]pi A B = pi ([x := N]A) ([x := weaken N 1]B)
--     := by congr
--   @[simp] lemma subst_lam {N : Term n} {B : Term (n + 1)}
--     : [x := N]lam A B = lam ([x := N]A) ([x := weaken N 1]B)
--     := by congr
--   @[simp] lemma subst_app {N A B : Term n}
--     : [x := N](app A B) = app ([x := N]A) ([x := N]B)
--     := by congr

--   lemma substitution {A : Term} : (Γ1 ++ [x : A] ++ Γ2) ⊢ t : B ->
--     Γ1 ⊢ N : A ->
--     (Γ1 ++ [x := N]Γ2) ⊢ [x := N]t : [x := N]B :=
--     λ j1 j2 => 
--       @Infer.rec
--       (λ Γ t B j => (Δ1 Δ2 : Map! (Term)) ->
--         Γ = Δ1 ++ [x : A] ++ Δ2 ->
--         Δ1 ⊢ N : A ->
--         (Δ1 ++ [x := N]Δ2) ⊢ [x := N]t : [x := N]B)
--       (λ Γ t B j => (Δ1 Δ2 : Map! (Term)) ->
--         Γ = Δ1 ++ [x : A] ++ Δ2 ->
--         Δ1 ⊢ N : A ->
--         (Δ1 ++ [x := N]Δ2) ⊢ [x := N]t >: [x := N]B)
--       (λ Γ t B j => (Δ1 Δ2 : Map! (Term)) ->
--         Γ = Δ1 ++ [x : A] ++ Δ2 ->
--         Δ1 ⊢ N : A ->
--         (Δ1 ++ [x := N]Δ2) ⊢ [x := N]t =: [x := N]B)
--       (λ Γ j => (Δ1 Δ2 : Map! (Term)) ->
--         Γ = Δ1 ++ [x : A] ++ Δ2 ->
--         Δ1 ⊢ N : A ->
--         ⊢ (Δ1 ++ [x := N]Δ2))
--       (by {
--         simp
--         intros Γ wf ih Δ1 Δ2 e j2
--         have lem1 := ih Δ1 Δ2 e j2
--         apply (Infer.ax lem1)
--       })
--       (by {
--         intros Γ Δ1 x' Δ2 C wf e ih E1 E2 e3 j2
--         sorry
--       })
--       (by {
--         intros Γ C B S ih1 ih2 ih3 ih4 Δ1 Δ2 e j2
--         simp
--         apply (Infer.pi1 _ _)
--         exact (x :: S)
--         apply (ih3 Δ1 Δ2 e j2)
--         intros y yn
--         have yn1 : y ∉ S := FvSet.not_mem_cons yn
--         have ynx : x ≠ y := ne_sym (FvSet.not_mem_head yn)
--         have lem2 := ih4 y yn1 Δ1 (Δ2 ++ [y : C]) (by { subst e; simp }) j2
--         simp at lem2; simp [*]
--       })
--       (by {
--         intros Γ C K B S ih1 ih2 ih3 ih4 Δ1 Δ2 e j2
--         simp
--         apply (Infer.pi2 _ _)
--         exact K
--         exact (x :: S)
--         apply (ih3 Δ1 Δ2 e j2)
--         intros y yn
--         have yn1 : y ∉ S := FvSet.not_mem_cons yn
--         have ynx : x ≠ y := ne_sym (FvSet.not_mem_head yn)
--         have lem2 := ih4 y yn1 Δ1 (Δ2 ++ [y : C]) (by { subst e; simp }) j2
--         simp at lem2; simp [*]
--       })
--       (by {
--         intros Γ A' K N' B S j1 j2 ih1 ih2 Δ1 Δ2 e j3; simp; simp at ih2
--         apply (Infer.lam _ _)
--         exact K
--         exact (x :: S)
--         apply (ih1 Δ1 Δ2 e j3)
--         intros y yn
--         have yn1 : y ∉ S := FvSet.not_mem_cons yn
--         have ynx : x ≠ y := ne_sym (FvSet.not_mem_head yn)
--         have lem2 := ih2 y yn1 Δ1 (Δ2 ++ [y : A']) (by { subst e; simp }) j3
--         rewrite [Syntax.open_subst ynx, Syntax.open_subst ynx]
--         simp at lem2; simp [*]
--       })
--       (by {
--         intros Γ M A' B N' j1 j2 ih1 ih2 Δ1 Δ2 e j3; simp
--         rewrite [Syntax.subst_head_subst]
--         apply Infer.app
--         apply ih1 Δ1 Δ2 e j3
--         apply ih2 Δ1 Δ2 e j3
--       })
--       (by {
--         intros Γ t C B j1 j2 ih Δ1 Δ2 e j3
--         have lem1 := ih Δ1 Δ2 e j3
--         have lem2 : [x := N]C -β>* [x := N]B := sorry
--         apply (ConInfer.infer lem1 lem2)
--       })
--       (by {
--         intros Γ t C B j1 j2 ih Δ1 Δ2 e j3
--         have lem1 := ih Δ1 Δ2 e j3
--         have lem2 : [x := N]C =β= [x := N]B := sorry
--         apply (Check.check lem1 lem2)
--       })
--       (by {
--         intros Δ1 Δ2 e j3
--         cases Δ1
--         simp at e; cases e; contradiction
--         contradiction
--       })
--       (by {
--         intros y Γ C K yn wf j3 ih1 ih2 Δ1 Δ2 e j4
--         have lem1 := Map.append_cases Δ2
--         cases lem1
--         case inl h => {
--           subst h; simp at e; simp
--           apply (infer_implies_wf j4)
--         }
--         case inr h => {
--           casesm* ∃ _ , _
--           case _ x' A' Δ3 e2 =>
--           subst e2
--           rewrite [<- List.append_assoc] at e
--           have lem1 := append_eq e
--           casesm* _ ∧ _
--           case _ l r =>
--           have lem := pair_eq r
--           casesm* _ ∧ _
--           case _ l' r' =>
--           subst l' r'; simp
--           have lem1 := ih1 Δ1 Δ3 l j4
--           have lem2 := ih2 Δ1 Δ3 l j4
--           rewrite [<- List.append_assoc]
--           simp at lem2
--           have yn2 : y ∉ Map.fv (Δ1 ++ [x := N]Δ3) := sorry 
--           apply (Wf.append yn2 lem1 lem2)
--         }
--       })
--       (Γ1 ++ [x : A] ++ Γ2)
--       (t)
--       (B)
--       (j1)
--       (Γ1)
--       (Γ2)
--       (by rfl)
--       (j2)

    

-- end SystemFOmega
